var g_data = {"name":"rtl/gemm/gemm_accelerator_top.sv","src":"//---------------------------\n// The 1-MAC GeMM accelerator top module\n//\n// Description:\n// This module implements a simple General Matrix-Matrix Multiplication (GeMM)\n// accelerator using a single Multiply-Accumulate (MAC) Processing Element (PE).\n// It interfaces with three SRAMs for input matrices A and B, and output matrix C.\n//\n// It includes a controller to manage the GeMM operation and address generation logic\n// for accessing the SRAMs based on the current matrix sizes and counters.\n//\n// Parameters:\n// - InDataWidth  : Width of the input data (matrix elements).\n// - OutDataWidth : Width of the output data (result matrix elements).\n// - AddrWidth    : Width of the address bus for SRAMs.\n// - SizeAddrWidth: Width of the size parameters for matrices.\n//\n// Ports:\n// - clk_i        : Clock input.\n// - rst_ni       : Active-low reset input.\n// - start_i      : Start signal to initiate the GeMM operation.\n// - M_size_i     : Size of matrix M (number of rows in A and C\n// - K_size_i     : Size of matrix K (number of columns in A and rows in B).\n// - N_size_i     : Size of matrix N (number of columns in B and C).\n// - sram_a_addr_o: Address output for SRAM A.\n// - sram_b_addr_o: Address output for SRAM B.\n// - sram_c_addr_o: Address output for SRAM C.\n// - sram_a_rdata_i: Data input from SRAM A.\n// - sram_b_rdata_i: Data input from SRAM B.\n// - sram_c_wdata_o: Data output to SRAM C.\n// - sram_c_we_o  : Write enable output for SRAM C.\n// - done_o       : Done signal indicating completion of the GeMM operation.\n//---------------------------\n\nmodule gemm_accelerator_top #(\n  parameter int unsigned InDataWidth = 8,\n  parameter int unsigned InDataWidth_a = 32,\n  parameter int unsigned InDataWidth_b = 128,\n  parameter int unsigned OutDataWidth = 32,\n  parameter int unsigned AddrWidth = 16,\n  parameter int unsigned SizeAddrWidth = 8,\n  parameter int unsigned RowPar = 4,\n  parameter int unsigned ColPar = 16\n) (\n  input  logic                                                   clk_i,\n  input  logic                                                   rst_ni,\n  input  logic                                                   start_i,\n  input  logic        [SizeAddrWidth-1:0]                        M_size_i,\n  input  logic        [SizeAddrWidth-1:0]                        K_size_i,\n  input  logic        [SizeAddrWidth-1:0]                        N_size_i,\n  output logic        [AddrWidth-1:0]                            sram_a_addr_o,\n  output logic        [AddrWidth-1:0]                            sram_b_addr_o,\n  output logic        [AddrWidth-1:0]                            sram_c_addr_o,\n  input  logic signed [InDataWidth_a-1:0]                        sram_a_rdata_i,\n  input  logic signed [InDataWidth_b-1:0]                        sram_b_rdata_i,\n  output logic signed [RowPar*ColPar*OutDataWidth-1:0] 		 sram_c_wdata_o,\n  output logic                                                   sram_c_we_o,\n  output logic                                                   done_o\n);\n\n  //---------------------------\n  // Wires\n  //---------------------------\n\n  logic [SizeAddrWidth-1:0] M_count;\n  logic [SizeAddrWidth-1:0] K_count;\n  logic [SizeAddrWidth-1:0] N_count;\n\n  logic busy;\n  logic valid_data;\n  assign valid_data = start_i || busy;\n\n  // define input data for mac array \n  logic [RowPar-1:0][InDataWidth-1:0]       DATA_input_A;\n  logic [ColPar-1:0][InDataWidth-1:0]       DATA_input_B;\n  logic [RowPar-1:0][ColPar-1:0][OutDataWidth-1:0] temp_C;\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This is a simple GeMM accelerator design using a single MAC PE.\n  // The controller manages just the counting capabilities.\n  // Check the gemm_controller.sv file for more details.\n  //\n  // Essentially, it tightly couples the counters and an FSM together.\n  // The address generation logic is just after this controller.\n  //\n  // You have the option to combine the address generation and controller\n  // all in one module if you prefer. We did this intentionally to separate tasks.\n  //---------------------------\n\n  // Main GeMM controller\n  gemm_controller #(\n    .AddrWidth      ( SizeAddrWidth )\n  ) i_gemm_controller (\n    .clk_i          ( clk_i       ),\n    .rst_ni         ( rst_ni      ),\n    .start_i        ( start_i     ),\n    .input_valid_i  ( valid_data  ),\n    .result_valid_o ( sram_c_we_o ),\n    .busy_o         ( busy        ),\n    .done_o         ( done_o      ),\n    .M_size_i       ( M_size_i     ),\n    .K_size_i       ( K_size_i    ),\n    .N_size_i       ( N_size_i     ),\n    .M_count_o      ( M_count     ),\n    .K_count_o      ( K_count     ),\n    .N_count_o      ( N_count     )\n  );\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the address generation logic for the input and output SRAMs.\n  // In our example, we made the assumption that both matrices A and B\n  // are stored in row-major order. yes\n  //\n  // Please adjust this part to align with your designed memory layout\n  // The counters are used for the matrix A and matrix B address generation;\n  // for matrix C, the corresponding address is calculated at the previous cycle,\n  // thus adding one cycle delay on c\n  //\n  // Just be careful to know on which cycle the addresses are valid.\n  // Align it carefully with the testbench's memory control.\n  //---------------------------\n  genvar m, n;\n\n  // Input addresses for matrices A and B\n  assign sram_a_addr_o = M_count * K_size_i + K_count;  // contains 4 inputs of 8bits (1 column)  == 32 bits\n  assign sram_b_addr_o = N_count * K_size_i + K_count ;  // contains 16 inputs of 8 bits (1 row)  == 128 bits\n\n\n  // assign input data to diff rows and cols of mac array\n  // Better: same orientation as packing\n  for (m = 0; m < RowPar; m++) begin : gen_a_addr\n    assign DATA_input_A[m] = sram_a_rdata_i[m*InDataWidth +: InDataWidth];\n  end\n\n  for (n = 0; n < ColPar; n++) begin : gen_b_addr\n    assign DATA_input_B[n] = sram_b_rdata_i[n*InDataWidth +: InDataWidth];\n  end\n\n\n  // Output address for matrix C\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      sram_c_addr_o <= '0;\n    end else if (1'b1) begin  // Always valid in this simple design\n      sram_c_addr_o <= M_count * (N_size_i / ColPar) + N_count;\n    end\n  end\n    \n \n\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the MAC PE instantiation and data path logic.\n  // Check the general_mac_pe.sv file for more details.\n  //\n  // In this example, we only use a single MAC PE hence it is a simple design.\n  // However, you can expand this part to support multiple PEs\n  // by adjusting the data widths and input/output connections accordingly.\n  //\n  // Systemverilog has a useful mechanism to generate multiple instances\n  // using generate-for loops.\n  // Below is an example of a 2D generate-for loop to create a grid of PEs.\n  //\n  // ----------- BEGIN CODE EXAMPLE -----------\n  // genvar m, k, n;\n  //\n  //   for (m = 0; m < M; m++) begin : gem_mac_pe_m\n  //     for (n = 0; n < N; n++) begin : gem_mac_pe_n\n  //         mac_module #(\n  //           < insert parameters >\n  //         ) i_mac_pe (\n  //           < insert port connections >\n  //         );\n  //     end\n  //   end\n  // ----------- END CODE EXAMPLE -----------\n  // \n  // There are many guides on the internet (or even ChatGPT) about generate-for loops.\n  // We will give it as an exercise to you to modify this part to support multiple MAC PEs.\n  // 	\n  // When dealing with multiple PEs, be careful with the connection alignment\n  // across different PEs as it can be tricky to debug later on.\n  // Plan this very carefully, especially when dealing with the correct data ports\n  // data widths, slicing, valid signals, and so much more.\n  //\n  // Additionally, this MAC PE is already output stationary.\n  // You have the freedom to change the dataflow as you see fit.\n  //---------------------------\n\n  // The MAC PE instantiation and data path logics\n  \n  for (m = 0; m < RowPar; m++) begin : gem_mac_pe_m\n    for (n = 0; n < ColPar; n++) begin : gem_mac_pe_n\n        general_mac_pe #(\n              .InDataWidth  ( InDataWidth            ),\n              .NumInputs    ( 1                      ),\n              .OutDataWidth ( OutDataWidth           )\n              ) i_mac_pe (\n              .clk_i        ( clk_i                  ),\n              .rst_ni       ( rst_ni                 ),\n              .a_i          ( DATA_input_A[m]      ),\n              .b_i          ( DATA_input_B[n]      ),\n              .a_valid_i    ( valid_data             ),\n              .b_valid_i    ( valid_data             ),\n              .init_save_i  ( sram_c_we_o || start_i ),\n              .acc_clr_i    ( !busy                  ),\n              .c_o          ( temp_C[m][n]   )\n            );\n    end\n  end\n\n  assign  sram_c_wdata_o = {>>{temp_C}};\n\n  \n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);