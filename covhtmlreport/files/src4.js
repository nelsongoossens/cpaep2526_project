var g_data = {"name":"rtl/gemm/gemm_controller.sv","src":"//---------------------------\n// The GeMM Controller Module\n//\n// Description:\n// This module implements the controller for the 1-MAC GeMM accelerator.\n// It manages the operation by controlling the M, K, and N counters,\n// which get into the address generation logic in the accelerator top.\n//\n// Unique to this controller is the interplay of counters and the\n// main state machine. The controller uses the counters' last value\n// signals to determine when to move to the next state.\n//\n// Parameters:\n// - AddrWidth : Width of the address bus for SRAMs and counters.\n//\n// Ports:\n// - clk_i        : Clock input.\n// - rst_ni       : Active-low reset input.\n// - start_i      : Start signal to initiate the GeMM operation.\n// - input_valid_i: Input valid signal indicating data is ready.\n// - result_valid_o: Result valid signal indicating output data is ready.\n// - busy_o       : Busy signal indicating the controller is processing.\n// - done_o       : Done signal indicating completion of the GeMM operation.\n// - M_size_i     : Size of matrix M (number of rows in A and C).\n// - K_size_i     : Size of matrix K (number of columns in A and rows in B).\n// - N_size_i     : Size of matrix N (number of columns in B and C).\n// - M_count_o    : Current count of M dimension.\n// - K_count_o    : Current count of K dimension.\n// - N_count_o    : Current count of N dimension.\n//---------------------------\n\nmodule gemm_controller #(\n  parameter int unsigned AddrWidth = 16\n)(\n  input  logic clk_i,\n  input  logic rst_ni,\n  input  logic start_i,\n  input  logic input_valid_i,\n  output logic result_valid_o,\n  output logic busy_o,\n  output logic done_o,\n  // The target M, K, and N sizes\n  input  logic [AddrWidth-1:0] M_size_i,\n  input  logic [AddrWidth-1:0] K_size_i,\n  input  logic [AddrWidth-1:0] N_size_i,\n  // The the current M, K, and N counts\n  output logic [AddrWidth-1:0] M_count_o,\n  output logic [AddrWidth-1:0] K_count_o,\n  output logic [AddrWidth-1:0] N_count_o\n);\n\n  //-----------------------\n  // Wires and logic\n  //-----------------------\n  logic move_K_counter;\n  logic move_N_counter;\n  logic move_M_counter;\n  logic move_counter;\n\n  assign move_K_counter = move_counter;\n\n  logic clear_counters;\n  logic last_counter_last_value;\n\n  // State machine states\n  typedef enum logic [1:0] {\n    ControllerIdle,\n    ControllerBusy,\n    ControllerFinish\n  } controller_state_t;\n\n  controller_state_t current_state, next_state;\n\n  assign busy_o = (current_state == ControllerBusy  ) ||\n                  (current_state == ControllerFinish);\n\n  //-----------------------\n  // DESIGN NOTE:\n  // Counters for M, K, and N dimensions.\n  // These counters are used to keep track of the current position\n  // in the matrix multiplication process.\n  //\n  // They are instantiated using a generic ceiling_counter module.\n  // Each counter increments based on the move_counter signal\n  // and resets when clear_counters is asserted.\n  //\n  // Practically, for a single MAC we use a simple for-loop scheme:\n  //\n  // for m = 0 to M-1\n  //   for n = 0 to N-1\n  //     for k = 0 to K-1\n  //       C[m][n] += A[m][k] * B[k][n]\n  //\n  // This is the dataflow that the counters help to manage.\n  // This will change when we start to have more spatial parallelism.\n  // For example, when we isert parfor loops, then the effective counters\n  // get divided by some parallelism factor S. Refer to lecture 3 again\n  // for more details on this.\n  //\n  // In the counter instantiations below, take note that\n  // the last_value_o output is used to signal when the counter\n  // has reached its ceiling value. This is crucial for the controller\n  // to determine when to transition states and manage the overall flow.\n  //-----------------------\n\n  // Counters for M, K, N\n\n  // K Counter\n  ceiling_counter #(\n    .Width        (      AddrWidth ),\n    .HasCeiling   (              1 )\n  ) i_K_counter (\n    .clk_i        ( clk_i          ),\n    .rst_ni       ( rst_ni         ),\n    .tick_i       ( move_K_counter ),\n    .clear_i      ( clear_counters ),\n    .ceiling_i    ( K_size_i       ),\n    .count_o      ( K_count_o      ),\n    .last_value_o ( move_N_counter )\n  );\n\n  // N Counter\n  ceiling_counter #(\n    .Width        (      AddrWidth ),\n    .HasCeiling   (              1 )\n  ) i_N_counter (\n    .clk_i        ( clk_i          ),\n    .rst_ni       ( rst_ni         ),\n    .tick_i       ( move_N_counter ),\n    .clear_i      ( clear_counters ),\n    .ceiling_i    ( N_size_i/16    ),\n    .count_o      ( N_count_o      ),\n    .last_value_o ( move_M_counter )\n  );\n\n  // M Counter\n  ceiling_counter #(\n    .Width        (               AddrWidth ),\n    .HasCeiling   (                       1 )\n  ) i_M_counter (\n    .clk_i        ( clk_i                   ),\n    .rst_ni       ( rst_ni                  ),\n    .tick_i       ( move_M_counter          ),\n    .clear_i      ( clear_counters          ),\n    .ceiling_i    ( M_size_i/4              ),\n    .count_o      ( M_count_o               ),\n    .last_value_o ( last_counter_last_value )\n  );\n\n  //-----------------------\n  // DESIGN NOTE:\n  // Below is the contoller state machine where we split the sequential\n  // updates from the change of states.\n  //\n  // When making FSMs, it's a good practice to separate the\n  // sequential logic (state updates) from the combinational logic\n  // (next state and outputs). This separation helps in\n  // avoiding unintended latches and makes the design clearer.\n  // You can clearly follow as you read along what each state does,\n  // and how the outputs change for the given state and a certain input.\n  // Note that the output of the counters are also inputs to the FSM logic.\n  // Hence that is why the counters and the FSM are tightly coupled together.\n  //\n  // Moreover, this FSM is more of a mealy machine, that means\n  // the output signals depend on both the current state and\n  // the inputs. This is evident in how result_valid_o and done_o\n  // are generated based on the current state and input conditions.\n  //\n  // Depending on how you want to design your controller,\n  // states and the operations can differ. Just make sure to be\n  // consistent with your design choices.\n  //-----------------------\n\n  // Main controller state machine\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      current_state <= ControllerIdle;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\n  always_comb begin\n    // Default assignments\n    next_state     = current_state;\n    clear_counters = 1'b0;\n    move_counter   = 1'b0;\n    result_valid_o = 1'b0;\n    done_o         = 1'b0;\n\n    case (current_state)\n      ControllerIdle: begin\n        if (start_i) begin\n          move_counter = input_valid_i;\n          next_state   = ControllerBusy;\n        end\n      end\n\n      ControllerBusy: begin\n        move_counter = input_valid_i;\n        // Check if we are done\n        if (last_counter_last_value) begin\n          next_state = ControllerFinish;\n        end else if (input_valid_i\n                     && K_count_o == '0 \n                     && (M_count_o != '0 || N_count_o != '0)) begin\n          // Check when result_valid_o should be asserted\n          result_valid_o = 1'b1;\n        end\n      end\n\n      ControllerFinish: begin\n        done_o         = 1'b1;\n        result_valid_o = 1'b1;\n        clear_counters = 1'b1;\n        next_state     = ControllerIdle;\n      end\n\n      default: begin\n        next_state = ControllerIdle;\n      end\n    endcase\n  end\nendmodule\n","lang":"verilog"};
processSrcData(g_data);