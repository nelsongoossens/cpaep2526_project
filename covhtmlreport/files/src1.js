var g_data = {"name":"tb/tb_gemm_variable_dimensions.sv","src":"`timescale 1ns/1ps\n\nmodule tb_gemm_variable_dimensions;\n\n  // ================================================================\n  // PARAMETERS\n  // ================================================================\n  parameter int InDataWidth    = 8;\n  parameter int RowPar         = 4;\n  parameter int ColPar         = 16;\n\n  parameter int InDataWidth_a  = RowPar * InDataWidth;     // 32 bits\n  parameter int InDataWidth_b  = ColPar  * InDataWidth;    // 128 bits\n  parameter int OutDataWidth   = 32;\n\n  parameter int DataDepth      = 4096;\n  parameter int AddrWidth      = (DataDepth <= 1) ? 1 : $clog2(DataDepth);\n  parameter int SizeAddrWidth  = 32;\n\n  localparam int TileSize       = RowPar * ColPar;         // 64\n  localparam int PackedOutWidth = TileSize * OutDataWidth; // 2048 bits\n\n\n\n  // ================================================================\n  // DUT SIGNALS\n  // ================================================================\n  logic clk_i;\n  logic rst_ni;\n  logic start_i;\n  logic done_o;\n\n  logic [SizeAddrWidth-1:0] M_i;\n  logic [SizeAddrWidth-1:0] K_i;\n  logic [SizeAddrWidth-1:0] N_i;\n\n  logic [AddrWidth-1:0] sram_a_addr_o;\n  logic [AddrWidth-1:0] sram_b_addr_o;\n  logic [AddrWidth-1:0] sram_c_addr_o;\n\n  logic signed [InDataWidth_a-1:0]  sram_a_rdata_i;\n  logic signed [InDataWidth_b-1:0]  sram_b_rdata_i;\n  logic signed [PackedOutWidth-1:0] sram_c_wdata_o;\n\n  logic sram_c_we_o;\n\n\n\n  // ================================================================\n  // INTERNAL TB STORAGE\n  // ================================================================\n  logic signed [OutDataWidth-1:0] C_scalar        [DataDepth];\n  logic signed [OutDataWidth-1:0] golden_results  [DataDepth];\n\n  int M_tiles;\n  int N_tiles;\n  int Total_tiles;\n\n\n\n  // ================================================================\n  // MEMORY MODELS\n  // ================================================================\n  single_port_memory #(\n    .DataWidth(InDataWidth_a),\n    .DataDepth(DataDepth),\n    .AddrWidth(AddrWidth)\n  ) memA (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .mem_addr_i(sram_a_addr_o),\n    .mem_we_i(1'b0),\n    .mem_wr_data_i('0),\n    .mem_rd_data_o(sram_a_rdata_i)\n  );\n\n  single_port_memory #(\n    .DataWidth(InDataWidth_b),\n    .DataDepth(DataDepth),\n    .AddrWidth(AddrWidth)\n  ) memB (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .mem_addr_i(sram_b_addr_o),\n    .mem_we_i(1'b0),\n    .mem_wr_data_i('0),\n    .mem_rd_data_o(sram_b_rdata_i)\n  );\n\n  single_port_memory #(\n    .DataWidth(PackedOutWidth),\n    .DataDepth(DataDepth),\n    .AddrWidth(AddrWidth)\n  ) memC (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .mem_addr_i(sram_c_addr_o),\n    .mem_we_i(sram_c_we_o),\n    .mem_wr_data_i(sram_c_wdata_o),\n    .mem_rd_data_o()\n  );\n\n\n\n  // ================================================================\n  // DUT\n  // ================================================================\n  gemm_accelerator_top #(\n    .InDataWidth(InDataWidth),\n    .InDataWidth_a(InDataWidth_a),\n    .InDataWidth_b(InDataWidth_b),\n    .OutDataWidth(OutDataWidth),\n    .AddrWidth(AddrWidth),\n    .SizeAddrWidth(SizeAddrWidth),\n    .RowPar(RowPar),\n    .ColPar(ColPar)\n  ) dut (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .start_i(start_i),\n    .M_size_i(M_i),\n    .K_size_i(K_i),\n    .N_size_i(N_i),\n    .sram_a_addr_o(sram_a_addr_o),\n    .sram_b_addr_o(sram_b_addr_o),\n    .sram_c_addr_o(sram_c_addr_o),\n    .sram_a_rdata_i(sram_a_rdata_i),\n    .sram_b_rdata_i(sram_b_rdata_i),\n    .sram_c_wdata_o(sram_c_wdata_o),\n    .sram_c_we_o(sram_c_we_o),\n    .done_o(done_o)\n  );\n\n\n\n  // ================================================================\n  // CLOCK GENERATION\n  // ================================================================\n  initial begin\n    clk_i = 1'b0;\n    forever #5 clk_i = ~clk_i;\n  end\n\n  task automatic clk_delay(input int n);\n    int i;\n    begin\n      for (i = 0; i < n; i++) begin\n        @(posedge clk_i);\n      end\n    end\n  endtask\n\n\n\n  // ================================================================\n  // START AND WAIT TASK\n  // ================================================================\n  task automatic start_and_wait();\n    int cycles;\n    begin\n      cycles = 0;\n\n      @(posedge clk_i);\n      start_i = 1'b1;\n\n      @(posedge clk_i);\n      start_i = 1'b0;\n\n      while (!done_o) begin\n        @(posedge clk_i);\n        cycles++;\n        if (cycles > 200000) begin\n          $display(\"ERROR: TIMEOUT waiting for done_o\");\n          $fatal;\n        end\n      end\n\n      @(posedge clk_i);\n      $display(\"DONE in %0d cycles\", cycles);\n    end\n  endtask\n\n\n\n  // ================================================================\n  // MEMORY INITIALIZATION A\n  // ================================================================\n  task automatic init_mem_A();\n    int rb;\n    int k;\n    int q;\n    int addr;\n    logic [InDataWidth_a-1:0] wordA;\n    begin\n      for (rb = 0; rb < M_tiles; rb++) begin\n        for (k = 0; k < K_i; k++) begin\n          addr = rb*K_i + k;\n          wordA = '0;\n          for (q = 0; q < RowPar; q++) begin\n            if (rb*RowPar + q < M_i)\n              //wordA[q*InDataWidth +: InDataWidth] = $urandom_range(0,255);\n              wordA[q*InDataWidth +: InDataWidth] = $urandom() % (2 ** InDataWidth);\n            else\n              wordA[q*InDataWidth +: InDataWidth] = 0;\n          end\n          memA.memory[addr] = wordA;\n        end\n      end\n    end\n  endtask\n\n\n\n  // ================================================================\n  // MEMORY INITIALIZATION B\n  // ================================================================\n  task automatic init_mem_B();\n    int cb;\n    int k;\n    int l;\n    int addr;\n    logic [InDataWidth_b-1:0] wordB;\n    begin\n      for (cb = 0; cb < N_tiles; cb++) begin\n        for (k = 0; k < K_i; k++) begin\n          addr = cb*K_i + k;\n          wordB = '0;\n          for (l = 0; l < ColPar; l++) begin\n            if (cb*ColPar + l < N_i)\n              // wordB[l*InDataWidth +: InDataWidth] = $urandom_range(0,255);\n              wordB[l*InDataWidth +: InDataWidth] = $urandom() % (2 ** InDataWidth);\n            else\n              wordB[l*InDataWidth +: InDataWidth] = 0;\n          end\n          memB.memory[addr] = wordB;\n        end\n      end\n    end\n  endtask\n\n\n\n  // ================================================================\n  // GOLDEN MODEL\n  // ================================================================\n  task automatic compute_golden();\n    int i;\n    int m;\n    int n;\n    int k;\n    int rb;\n    int off_m;\n    int cb;\n    int off_n;\n    int gm;\n    int gn;\n    int tile_m;\n    int tile_n;\n    int q;\n    int l;\n    int tile_index;\n\n    int addrA;\n    int addrB;\n    logic signed [InDataWidth-1:0] a_val;\n    logic signed [InDataWidth-1:0] b_val;\n\n    longint acc;\n\n    begin\n      for (i = 0; i < DataDepth; i++) begin\n        C_scalar[i]       = 0;\n        golden_results[i] = 0;\n      end\n\n      for (m = 0; m < M_i; m++) begin\n        for (n = 0; n < N_i; n++) begin\n          acc = 0;\n\n          rb    = m / RowPar;\n          off_m = m % RowPar;\n          cb    = n / ColPar;\n          off_n = n % ColPar;\n\n          for (k = 0; k < K_i; k++) begin\n            addrA = rb*K_i + k;\n            addrB = cb*K_i + k;\n\n            a_val = memA.memory[addrA][off_m*InDataWidth +: InDataWidth];\n            b_val = memB.memory[addrB][off_n*InDataWidth +: InDataWidth];\n\n            acc += $signed(a_val) * $signed(b_val);\n          end\n\n          C_scalar[m*N_i + n] = acc;\n        end\n      end\n\n      for (tile_m = 0; tile_m < M_tiles; tile_m++) begin\n        for (tile_n = 0; tile_n < N_tiles; tile_n++) begin\n\n          tile_index = tile_m*N_tiles + tile_n;\n\n          for (q = 0; q < RowPar; q++) begin\n            for (l = 0; l < ColPar; l++) begin\n              gm = tile_m*RowPar + q;\n              gn = tile_n*ColPar + l;\n              if (gm < M_i && gn < N_i)\n                golden_results[tile_index*TileSize + (q*ColPar + l)] =\n                  C_scalar[gm*N_i + gn];\n            end\n          end\n\n        end\n      end\n    end\n  endtask\n\n\n\n  // ================================================================\n  // VERIFY TILES\n  // ================================================================\n  // ================================================================\n  // VERIFY TILES — with full per-element printing\n  // ================================================================\n	task automatic verify_tiles();\n	  int t;\n	  int i;\n	  logic signed [PackedOutWidth-1:0] data;\n	  logic signed [OutDataWidth-1:0] actual;\n	  logic signed [OutDataWidth-1:0] golden;\n\n	  begin\n	    $display(\"Verifying %0d tiles...\", Total_tiles);\n\n	    for (t = 0; t < Total_tiles; t++) begin\n	      data = memC.memory[t];\n\n	      $display(\"\\n-----------------------------------------------\");\n	      $display(\" TILE %0d\", t);\n	      $display(\"-----------------------------------------------\");\n\n	      for (i = 0; i < TileSize; i++) begin\n		      actual = data[i*OutDataWidth +: OutDataWidth];\n		      golden = golden_results[t*TileSize + i];\n\n		      // if (actual === golden) begin\n		      //   $display(\"  Tile %0d Elem %0d : OK     | actual = %0d (0x%h) | golden = %0d (0x%h)\",\n		      //       t, i, actual, actual, golden, golden);\n		      // end\n		      // else begin\n		      //   $display(\"  Tile %0d Elem %0d : MISMATCH!\", t, i);\n		      //   $display(\"       actual = %0d (0x%h)\", actual, actual);\n		      //   $display(\"       golden = %0d (0x%h)\", golden, golden);\n		      //   $fatal;   // stop immediately on mismatch\n		      // end\n          if (actual !== golden) begin\n            $display(\"  Tile %0d Elem %0d : MISMATCH!\", t, i);\n		        $display(\"       actual = %0d (0x%h)\", actual, actual);\n		        $display(\"       golden = %0d (0x%h)\", golden, golden);\n		        $fatal;   // stop immediately on mismatch\n          end\n	      end\n\n	      $display(\"Tile %0d verification COMPLETE — all elements match.\\n\", t);\n	    end\n\n	    $display(\"ALL tiles verified OK.\");\n	  end\n	endtask\n\n\n  // ================================================================\n  // MAIN TEST SEQUENCE — TWO TESTS\n  // ================================================================\n  initial begin\n\n    clk_i   = 0;\n    rst_ni  = 0;\n    start_i = 0;\n\n    clk_delay(5);\n    rst_ni = 1;\n\n    // ------------------------------------------------------------\n    // TEST 1: 32×32 multiply 32×32\n    // ------------------------------------------------------------\n    $display(\"\\n========== TEST 1: 32X32 - Case 3 ==========\\n\");\n\n    M_i = 32;\n    K_i = 32;\n    N_i = 32;\n\n    M_tiles     = (M_i + RowPar - 1) / RowPar;   // 8\n    N_tiles     = (N_i + ColPar - 1) / ColPar;   // 2\n    Total_tiles = M_tiles * N_tiles;             // 16\n\n    init_mem_A();\n    init_mem_B();\n    compute_golden();\n    clk_delay(2);\n    start_and_wait();\n    verify_tiles();\n\n    $display(\"TEST 1 PASSED.\\n\");\n\n\n    // ------------------------------------------------------------\n    // TEST 2: 4×64 multiply 64×16 (one tile)\n    // ------------------------------------------------------------\n    $display(\"\\n========== TEST 2: 4X64 X 64X16 - Case 1 ==========\\n\");\n\n    M_i = 4;\n    K_i = 64;\n    N_i = 16;\n\n    M_tiles     = (M_i + RowPar - 1) / RowPar;   // 1\n    N_tiles     = (N_i + ColPar - 1) / ColPar;   // 1\n    Total_tiles = 1;\n\n    init_mem_A();\n    init_mem_B();\n    compute_golden();\n    clk_delay(2);\n    start_and_wait();\n    verify_tiles();\n\n    $display(\"TEST 2 PASSED.\\n\");\n\n    // ------------------------------------------------------------\n    // TEST 3: 16×64 multiply 64×4 (one tile)\n    // Put transposed A in sram_B, put transposed B in sram_A --> answer is transposed C in sram_C\n    // ------------------------------------------------------------\n    $display(\"\\n========== TEST 3: 16X64 X 64X4 - Case 2 ==========\\n\");\n\n    M_i = 4;\n    K_i = 64;\n    N_i = 16;\n\n    M_tiles     = (M_i + RowPar - 1) / RowPar;   // 1\n    N_tiles     = (N_i + ColPar - 1) / ColPar;   // 1\n    Total_tiles = 1;\n\n    init_mem_A();\n    init_mem_B();\n    compute_golden();\n    clk_delay(2);\n    start_and_wait();\n    verify_tiles();\n\n    $display(\"TEST 3 PASSED.\\n\");    \n\n    $display(\"====================================\");\n    $display(\"           ALL TESTS PASSED\");\n    $display(\"====================================\");\n\n    $finish;\n  end\n\nendmodule\n\n","lang":"verilog"};
processSrcData(g_data);